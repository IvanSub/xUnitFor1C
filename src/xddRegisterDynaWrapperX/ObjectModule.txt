Перем	ИМЯ_КЛАССА_DynamicWrapperX;

Перем WinAPI;

Перем WshShell; // Экспорт;
Перем ФайлРегистратораКомпонент; // Экспорт;
Перем ИсполнительСкрытыхКомандСистемы;
Перем ПапкаВнешнихКомпонент; // Экспорт;

Функция Версия() Экспорт 
	Возврат "1.10.1";
КонецФункции

#Если Клиент Тогда

Функция ЗарегистрироватьWinAPI() Экспорт 
	ПапкаВнешнихКомпонент = Новый Файл(КаталогВременныхФайлов());
	
	WshShell = Новый COMОбъект("WScript.Shell");

	WinAPI = "НеИнициализирован";
	WinAPI = ПолучитьWinAPI();
КонецФункции

Функция ЭтоПлатформа_81()
	Перем локальная;
	этоПлатформа_81 = Истина;
	Попытка
		Выполнить("локальная = Метаданные.РежимСовместимости");		
		этоПлатформа_81 = Ложь;
	Исключение
	КонецПопытки; 
	Возврат этоПлатформа_81;
КонецФункции

#КонецЕсли

// ================================== ================================== ==================================
//
// блок кода из "Инструменты разработчика"
//
// ================================== ================================== ==================================

#Если Клиент Тогда

// Получает новый экземпляр ком-объекта парсера.
//
// Параметры:
//  Нет.
//
// Возвращаемое значение:
//  Com-объект, Неопределено.
//
Функция ПолучитьWinAPI() //Экспорт

	Если WinAPI = "НеИнициализирован" Тогда
		WinAPI = ПолучитьCOMОбъектИзМакета(ИМЯ_КЛАССА_DynamicWrapperX, ИМЯ_КЛАССА_DynamicWrapperX);
		Если WinAPI <> Неопределено Тогда
			//WinAPI.Register( "KERNEL32.DLL","Sleep","i=h","f=s");
			////WinAPI.Register( "KERNEL32.DLL","GetTickCount64","r=l","f=s"); // обычный DynamicWrapper на x86 подключает, а этот - нет
			//WinAPI.Register( "KERNEL32.DLL","GetTickCount","r=l","f=s");
			//WinAPI.Register( "KERNEL32.DLL","GetProcessId","i=l","r=l","f=s");
			//WinAPI.Register( "KERNEL32.DLL","GetCurrentProcessId","r=l","f=s");
			//WinAPI.Register( "WINMM.DLL", "timeGetTime",            "r=l", "f=s");
			//WinAPI.Register( "WINMM.DLL", "timeBeginPeriod", "i=l", "r=l", "f=s");
			//WinAPI.Register( "WINMM.DLL", "timeEndPeriod",   "i=l", "r=l", "f=s");
		Иначе
			// Под пользователем ОС без админских прав сразу после установки через regsvr32 /i компонента не создается почему то.
			// Нужно перезапускать приложение.
			Предупреждение("Установлена новая компонента. Сеанс будет перезапущен", 5);
			ПрекратитьРаботуСистемы(Истина);
		КонецЕсли;
	КонецЕсли;
	Возврат WinAPI;

КонецФункции // ПолучитьWinAPI()

#КонецЕсли

Функция ЗарегистрироватьПолучитьCOMОбъект(КлассКомпоненты, ПолноеИмяDll) //Экспорт
	
	// Сначала пробуем зарегистрировать для HKLM
	КоманднаяСтрока = "regsvr32 /s """ + ПолноеИмяDll + """";
	//КомандаСистемы(КоманднаяСтрока);
	ЗапуститьСкрытоеПриложениеИДождатьсяЗавершения(КоманднаяСтрока, , Истина);
	Попытка
		Компонента = Новый COMОбъект(КлассКомпоненты);
	Исключение
	КонецПопытки;
	Если Компонента <> Неопределено Тогда 
		Сообщить("Зарегистрирована COM-компонента " + КлассКомпоненты, СтатусСообщения.Информация);
		Возврат Компонента;
	КонецЕсли;
	
	// Теперь пробуем зарегистрировать для HKCU
	КоманднаяСтрока = "regsvr32 /s /i""" + ПолноеИмяDll + """";
	//КомандаСистемы(КоманднаяСтрока);
	ЗапуститьСкрытоеПриложениеИДождатьсяЗавершения(КоманднаяСтрока, , Истина);
	Попытка
		Компонента = Новый COMОбъект(КлассКомпоненты);
	Исключение
	КонецПопытки;
	Если Компонента <> Неопределено Тогда 
		Сообщить("Зарегистрирована COM-компонента " + КлассКомпоненты, СтатусСообщения.Информация);
		Возврат Компонента;
	КонецЕсли;
	
	Если ФайлРегистратораКомпонент = Неопределено Тогда
		ФайлРегистратораКомпонент = Новый Файл(ПолучитьИмяВременногоФайла("exe"));
		ПолучитьМакет("regsvrex").Записать(ФайлРегистратораКомпонент.ПолноеИмя);
	КонецЕсли;
	
	// Теперь пробуем зарегистрировать для HKCU через сторонний регистратор
	КоманднаяСтрока = """" + ФайлРегистратораКомпонент.ПолноеИмя + """ /c /s """ + ПолноеИмяDll + """";
	//КомандаСистемы(КоманднаяСтрока);
	ЗапуститьСкрытоеПриложениеИДождатьсяЗавершения(КоманднаяСтрока, , Истина);
	Попытка
		Компонента = Новый COMОбъект(КлассКомпоненты);
	Исключение
	КонецПопытки;
	Если Компонента <> Неопределено Тогда 
		Сообщить("Зарегистрирована COM-компонента " + КлассКомпоненты, СтатусСообщения.Информация);
		Возврат Компонента;
	КонецЕсли;
	
	// Теперь пробуем зарегистрировать для HKCU через сторонний регистратор
	КоманднаяСтрока = """" + ФайлРегистратораКомпонент.ПолноеИмя + """ /c /s /i """ + ПолноеИмяDll + """";
	//КомандаСистемы(КоманднаяСтрока);
	ЗапуститьСкрытоеПриложениеИДождатьсяЗавершения(КоманднаяСтрока, , Истина);
	Попытка
		Компонента = Новый COMОбъект(КлассКомпоненты);
	Исключение
	КонецПопытки;
	Если Компонента <> Неопределено Тогда 
		Сообщить("Зарегистрирована COM-компонента " + КлассКомпоненты, СтатусСообщения.Информация);
		Возврат Компонента;
	КонецЕсли;
	
	Сообщить("Не удалось зарегистривать COM-компоненту " + КлассКомпоненты + ". Возможно требуются права администратора ОС",
		СтатусСообщения.Внимание);
	Возврат Неопределено;

КонецФункции // ЗарегистрироватьПолучитьCOMОбъект

// Возвращает нужный com-объект. Если компонента не зарегистрирована, то пытается ее сохранить из макета и зарегистрировать.
//
// Параметры:
//  Нет.
//
// Возвращаемое значение:
//  COM-объект, Неопределено.
//
Функция ПолучитьCOMОбъектИзМакета(ИмяКомпоненты, КлассКомпоненты, КаталогУстановки = "авто") //Экспорт

	Попытка
		Компонента = Новый COMОбъект(КлассКомпоненты);
		
		// -- Артур -- 14.09.2011 - вставка в код ИР
		Если КлассКомпоненты = ИМЯ_КЛАССА_DynamicWrapperX Тогда
			Попытка
				л = Компонента.GetIDispatch(Компонента);
				Возврат Компонента;
			Исключение
				//ВызватьИсключение "Зарегистрирована старая версия COM-объекта DynamicWrapperX";
			КонецПопытки;
		КонецЕсли; 
			//Возврат Компонента;
		// --завершение
		
	Исключение
	КонецПопытки;

	#Если Клиент Тогда
	Если КаталогУстановки = "" Тогда
		Ответ = Вопрос("Для работы данной функции необходимо зарегистрировать 
			//|(необходимы права локального администратора)
			|	COM-компоненту """ + ИмяКомпоненты + """. Выполнить регистрацию?",
			РежимДиалогаВопрос.ОКОтмена, 30, КодВозвратаДиалога.Отмена);
		Если Ответ = КодВозвратаДиалога.Отмена Тогда
			Возврат Неопределено;
		КонецЕсли;
		ВыборФайла = Новый ДиалогВыбораФайла(РежимДиалогаВыбораФайла.ВыборКаталога);
		ВыборФайла.Заголовок = "Укажите папку, куда установить компоненту.";
		Если Не ВыборФайла.Выбрать() Тогда
			Возврат Неопределено;
		КонецЕсли;
		КаталогУстановки = ВыборФайла.Каталог;
	ИначеЕсли Нрег(КаталогУстановки) = Нрег("авто") Тогда
		КаталогУстановки = ПапкаВнешнихКомпонент.ПолноеИмя;
	КонецЕсли;
	ФайлКомпоненты = Новый Файл(КаталогУстановки + "\" + ИмяКомпоненты + ".dll");
	Если Не ФайлКомпоненты.Существует() Тогда 
		ПолучитьМакет(ИмяКомпоненты).Записать(ФайлКомпоненты.ПолноеИмя);
	КонецЕсли;
	
	Результат = ЗарегистрироватьПолучитьCOMОбъект(КлассКомпоненты, ФайлКомпоненты.ПолноеИмя);
	#Иначе
	Результат = Неопределено;
	#КонецЕсли
	Возврат Результат;

КонецФункции // ПолучитьCOMОбъектИзМакета()

// <Описание процедуры>
//
// Параметры:
//  <Параметр1>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>;
//  ИмяФайлаРезультата – Краткое имя файла, в который будет выведен выходной поток, только в текущем каталоге.
//
Процедура ЗапуститьСкрытоеПриложениеИДождатьсяЗавершения(Знач СтрокаЗапуска, ТекущийКаталог = "\.", ИспользоватьWSH = Ложь,
	КраткоеИмяФайлаРезультата = "") //Экспорт 

	#Если Клиент Тогда
	// Баг платформы здесь будет работать. Во время работы данной строки окно продолжает принимать команды! 
	// WSH не использовать при генерации внешних обработок
	Если ИспользоватьWSH Тогда
	#КонецЕсли
		WshShell.CurrentDirectory = ТекущийКаталог;
		СтрокаЗапуска = "cmd.exe /c """ + СтрокаЗапуска + """";
		Если КраткоеИмяФайлаРезультата <> "" Тогда
			СтрокаЗапуска = СтрокаЗапуска + " > " + КраткоеИмяФайлаРезультата;
			СтрокаЗапуска = СтрокаЗапуска + " 2>&1"; //stderr
		КонецЕсли;
		Попытка
			WshShell.Run(СтрокаЗапуска, 0, Истина);
		Исключение
			// Для x64 ОС
			СтрокаЗапуска = "%windir%\Sysnative\" + СтрокаЗапуска;
			WshShell.Run(СтрокаЗапуска, 0, Истина);
		КонецПопытки;
	#Если Клиент Тогда
	Иначе
		ПолучитьИсполнительСкрытыхКомандСистемы();
		КонечнаяСтрока = ИсполнительСкрытыхКомандСистемы + " /nowindow /wait /silent /D=""" + ТекущийКаталог + """ " + СтрокаЗапуска;
		ЗапуститьПриложение(КонечнаяСтрока, , Истина);
	КонецЕсли;
	#КонецЕсли
	
КонецПроцедуры // ЗапуститьСкрытоеПриложениеИДождатьсяЗавершения()

Функция ПолучитьИсполнительСкрытыхКомандСистемы() //Экспорт
	
	Если ИсполнительСкрытыхКомандСистемы = Неопределено Тогда
		ДвоичныеДанные = ПолучитьОбщийМакет("hstart");
		ИсполнительСкрытыхКомандСистемы = ПолучитьИмяВременногоФайла("exe");
		ДвоичныеДанные.Записать(ИсполнительСкрытыхКомандСистемы);
		ИсполнительСкрытыхКомандСистемы = """" + ИсполнительСкрытыхКомандСистемы + """";
	КонецЕсли;
	Возврат ИсполнительСкрытыхКомандСистемы;
	
КонецФункции

// ================================== ================================== ==================================
//
// окончание блока кода из "Инструменты разработчика"
//
// ================================== ================================== ==================================

ИМЯ_КЛАССА_DynamicWrapperX = "DynamicWrapperX";

//#Если Клиент Тогда
//	
//	Инит();
//	
//#КонецЕсли
